# C++

### 封装（Encapsulation）

**概念：**
 封装是将数据（成员变量）和操作数据的方法（成员函数）绑定在一起，并隐藏内部实现细节，只对外暴露必要接口。

**作用：**

提高代码的**安全性**（通过访问控制如 private/protected）

提高模块的**可维护性**和**复用性**

###  继承（Inheritance）

**概念：**
 继承是面向对象中子类复用父类属性和方法的机制。子类可以继承父类的成员，也可以扩展或重写它们。

**作用：**

- 提高代码的**复用性**
- 实现类之间的**层次结构**

### 多态（Polymorphism）

**概念：**
 多态允许同一个接口调用不同的实现。主要通过**虚函数**实现，在运行时根据对象实际类型决定调用哪个函数（即运行时多态）。

```
class Animal {
public:
    virtual void speak() { std::cout << "Animal sound" << std::endl; }
};

class Dog : public Animal {
public:
    void speak() override { std::cout << "Bark" << std::endl; }
};

void makeSound(Animal* a) {
    a->speak();  // 根据传入对象不同，表现不同
}
```



---

#  STL 常用容器

###  1. `vector` —— 动态数组容器

**特点：**

- 连续内存空间，支持随机访问（`O(1)`）
- 尾部插入/删除效率高（`push_back` 是均摊 `O(1)`）

**底层实现：**

- 基于**动态数组**，内存空间不足时会**成倍扩容**（一般是2倍），并**重新拷贝原有元素**
- 扩容代价较高，频繁插入建议预分配（`reserve`）

### 2. `deque` —— 双端队列容器

**特点：**

- 支持**头尾两端的快速插入与删除**（`O(1)`）
- 也支持随机访问（`O(1)`）

**底层实现：**

- 不是连续的大块内存，而是**多个小块连续内存块的数组指针管理结构**
- 类似二维数组结构：**中央控制器（map）+ 分段缓存块（buffer）**

###  3. `set` —— 有序集合（不重复）

**特点：**

- 元素自动排序（默认升序）
- 不允许重复元素
- 插入、删除、查找时间复杂度为 `O(log n)`

**底层实现：**

- 基于**红黑树（self-balancing binary search tree）**
- 插入时自动保持平衡 + 有序性

###  4. `map` —— 有序键值对容器

**特点：**

- 每个元素是一个**key-value对**（键值唯一）
- 按 key 自动排序，支持范围查询（区间遍历）
- 插入、查找、删除复杂度为 `O(log n)`

**底层实现：**

- 同样基于 **红黑树**
- 所有操作基于 key 的有序结构实现

### 5. `unordered_map` / `unordered_set` —— 哈希容器

**特点：**

- **无序容器**，不维护元素顺序
- 插入、查找平均复杂度为 `O(1)`（最坏情况 `O(n)`）

**底层实现：**

- 基于**哈希表（Hash Table）**实现，利用哈希函数将 key 映射到对应的桶中
- 冲突处理方式通常是**链地址法（拉链法）**

------

### ✅ 总结对比表：

| 容器            | 是否有序 | 是否允许重复 | 底层结构     | 时间复杂度（查找/插入） |
| --------------- | -------- | ------------ | ------------ | ----------------------- |
| `vector`        | 否       | 是           | 动态数组     | `O(1)` / `O(n)`         |
| `deque`         | 否       | 是           | 分段连续内存 | `O(1)` / `O(1)`         |
| `set`           | 是       | 否           | 红黑树       | `O(log n)`              |
| `map`           | 是       | key 不重复   | 红黑树       | `O(log n)`              |
| `unordered_set` | 否       | 否           | 哈希表       | `O(1)`（均摊）          |
| `unordered_map` | 否       | key 不重复   | 哈希表       | `O(1)`（均摊）          |



# ROS

## ROS 通信三大机制对比

| 类型        | 特点                              | 使用场景                             |
| ----------- | --------------------------------- | ------------------------------------ |
| **Topic**   | 发布/订阅，**单向异步**           | 连续数据流，如图像、IMU、激光雷达    |
| **Service** | 请求/应答，**同步、阻塞式**       | 查询一次性结果，如获取状态、设置参数 |
| **Action**  | 请求/反馈/取消，**异步+持续反馈** | 长时间任务，如路径规划、机械臂控制   |



## 🟣 Action：异步 + 反馈 + 可取消（适合长任务）

需要用 `action_msgs` 定义目标、反馈、结果，过程较长。

### 简化理解：

- 客户端发起请求
- 服务端开始执行（可能很慢）
- 期间持续发送反馈 progress
- 最后返回执行结果（或被取消）

Action 通信在 ROS 中广泛应用于需要长时间运行、实时反馈和任务管理的场景。经典的应用包括机器人导航、机械臂控制、物体抓取、路径规划等。通过 Action，ROS 提供了一种高效、灵活的通信机制，适用于复杂的机器人任务。



# SLAM算法

大体可以分为三大类：基于滤波的方法、基于图优化的方法和基于直接法。

**基于滤波的方法**

通常利用概率框架来估计机器人的位姿，并同时构建地图。EKF-SLAM是最著名的基于滤波的SLAM实例之一，它的核心思想是在每个时刻用扩展卡尔曼滤波器来估计机器人的状态。这种方法的缺点在于计算复杂度随着状态数量的增长而迅速增加，这在长时间运行的SLAM任务中可能造成问题。

**基于图优化的方法** 

通过构建一个由节点（代表机器人位置）和边（代表运动或观测约束）组成的因子图来优化整个轨迹和地图。这种方法能够在全局范围内进行优化，从而纠正累积的误差，适用于大规模环境的SLAM任务。

**基于直接法** 

的SLAM方法利用图像像素的原始数据进行优化，不需要提取特征，从而减少了信息损失，并且更容易处理动态环境。直接法在处理低纹理或者无特征环境时表现更佳，但在计算上更为昂贵。


# Carto

1️⃣ 点云输入 (/scan or /laser)
↓
2️⃣ 数据预处理（滤波、时间校正）
↓
3️⃣ 运动估计（IMU/里程计）
↓
4️⃣ 扫描匹配（Scan Matching）
↓
5️⃣ 子图构建（Submap）
↓
6️⃣ 闭环检测 + 图优化（后端）
↓
7️⃣ 生成最终地图 + 轨迹





### 2️⃣ 数据预处理：

**降采样：**

按体素网格将点云划分成小立方体（voxel）每个体素只保留一个点（比如第一个、中心点等） voxel_filter_size = 0.05  -- 体素滤波精度

**运动畸变补偿：**

对位置（平移）部分进行线性插值

对方向（旋转）部分使用 SLERP 插值（用于四元数间平滑插值）



### 3️⃣ 运动估计

使用 IMU（角速度）插值出该时间点的预测朝向（旋转）

使用 odom 或 IMU 加速度估计位置（平移）

得到预测位姿 → 作为 Scan Matching 的初值



### 4️⃣ scan matching：

1. **Real-Time Correlative Scan Matching（粗匹配）**

   构建一个离散搜索窗口：平移 ±`x` cm 旋转 ±`θ` 角度

   使用离散栅格地图匹配，点云落在高概率栅格上的越多，得分越高

2. **Ceres Scan Matcher（非线性优化）**